Overall
=======

- Parse graph & build adjacency matrix.
- Get the number of paths, N, to print from the nodes input file.
- For each remaining line in the nodes input file:
  - Parse a start node S
  - Find the first N maximal paths from the start node S and print them out
  - Calculate the number of maximal paths from the start node and print it out.


Finding the number of maximal paths
===================================

- Depth first search?
  - How to parallelise it efficiently?
- May be able to accelerate the counting by recording the number of outgoing
  edges from each node?


Data structures
===============

- Graph data structure
  - Traversal must be as fast as possible.
  - Adjacency matrix is likely to be the quickest.
  - Using a bit-field representation, would only require about 11 Mb for the
    largest allowed graph.

- Path data structure
  - Need to be able to quickly check whether a node is already on the path.
  - Order of nodes in the path is important
  - Store as a combination of bit-mask and node list?


Notes
=====

- May be quicker to have separate functions for counting all paths and for
  printing the first N paths?
- Can we calculate prefix and/or suffix path lists for each node as a way to
  speed things up?

- Parallelise by splitting the tree into subtrees:

      _ a _
     /     \
    b       c            a     d     e     f     g
   / \     / \    ===>  / \ , / \ , / \ , / \ , / \
  d   e   f   g         b c   h i   j k   l m   n o
 / \ / \ / \ / \
 h i j k l m n o

- Total number of nodes in each subtree should be big enough that the cost of
  evaluating them all on a single thread would outweigh the cost of splitting
  out the multiple threads.

- Use tbb::parallel_do with a feeder to pass in the subtrees.

- The requirement to count all the maximal paths precludes a lot of
  optimisations.

- The key thing is having a quick test for whether a node has already been
  visited, without relying on serial behaviour.
- Or... remove each node from the graph as you visit it!
